import os
import sys
from typing import Dict, List, Optional, Union, Iterable, Tuple
import numpy as np
import pandas as pd
import matplotlib
matplotlib.use('Agg')  # Use non-interactive backend for deployment
import matplotlib.pyplot as plt
from concurrent.futures import ThreadPoolExecutor, as_completed

# Optional progress bar
try:
    from tqdm import tqdm
except Exception:
    tqdm = None

# Add current directory to path for imports
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from lob import LimitOrderBook
from strategies import MarketMaker, MomentumStrategy
from ml_strategy import MLMarketMaker, MLMomentumStrategy, create_training_data_from_historical
from data_generator import SyntheticLOBGenerator
# Real-data CSVs should be generated by real_lob_generator.py


class LOBBacktester:
    """
    Fast backtester for limit order book strategies.
    Optimizations:
      - Typed CSV load (fewer dtype conversions)
      - Precomputed event stream (per-timestamp batches)
      - NumPy arrays instead of row objects inside loops
      - Reuse loaded data across strategies
    """

    def __init__(self, data_source: Union[str, SyntheticLOBGenerator], show_progress: bool = True):
        self.data_source = data_source
        self.results: Dict[str, Dict] = {}
        self.show_progress = show_progress
        # Precompute event stream once; reused by all runs
        self._data_df: Optional[pd.DataFrame] = None
        self._event_stream: Optional[List[Tuple[int, np.ndarray, np.ndarray, np.ndarray]]] = None

    # ------------------------- Loading & Precompute -------------------------

    def load_data(self) -> pd.DataFrame:
        """Load order book data as a typed DataFrame (cached)."""
        if self._data_df is not None:
            return self._data_df

        if isinstance(self.data_source, str):
            # Typed CSV read (much faster than default)
            dtypes = {
                "timestamp": "int64",
                "side": "category",
                "price": "float64",
                "size": "float64",
            }
            df = pd.read_csv(self.data_source, dtype=dtypes, nrows=100000)  # Limit to 5K rows for testing
            # Ensure expected columns exist
            for c in ("timestamp", "side", "price", "size"):
                if c not in df.columns:
                    raise ValueError(f"CSV missing column: {c}")
            df.sort_values("timestamp", kind="mergesort", inplace=True)
            self._data_df = df
            return df
        else:
            # Generate synthetic data once
            data = []
            # You can tune how many updates you want
            for update in self.data_source.generate_updates(5000):
                ts = int(update["timestamp"])
                orders = update["orders"]
                # Preallocate small local list for speed
                for od in orders:
                    data.append((ts, od["side"], float(od["price"]), float(od["size"])))
            df = pd.DataFrame(data, columns=["timestamp", "side", "price", "size"])
            df["side"] = df["side"].astype("category")
            df.sort_values("timestamp", kind="mergesort", inplace=True)
            self._data_df = df
            return df

    def _build_event_stream(self) -> List[Tuple[int, np.ndarray, np.ndarray, np.ndarray]]:
        """
        Convert DataFrame into a compact list:
          [(timestamp, side_array, price_array, size_array), ...]
        so inner loops avoid pandas overhead.
        """
        if self._event_stream is not None:
            return self._event_stream

        df = self.load_data()
        stream: List[Tuple[int, np.ndarray, np.ndarray, np.ndarray]] = []

        # groupby on np array is slower; use pandas groupby but only once
        grouped = df.groupby("timestamp", sort=False)
        # tqdm if available and enabled
        iterator = grouped
        if self.show_progress and tqdm is not None:
            iterator = tqdm(grouped, desc="Precomputing event stream", total=len(grouped))

        for ts, g in iterator:
            sides = g["side"].to_numpy()
            prices = g["price"].to_numpy(dtype=np.float64, copy=False)
            sizes = g["size"].to_numpy(dtype=np.float64, copy=False)
            stream.append((int(ts), sides, prices, sizes))

        self._event_stream = stream
        return stream

    # ------------------------------ Strategies -----------------------------

    def _make_strategy(self, strategy_name: str, **strategy_kwargs):
        s = strategy_name.lower()
        if s == "market_maker":
            return MarketMaker(**strategy_kwargs)
        if s == "momentum":
            return MomentumStrategy(**strategy_kwargs)
        if s == "ml_market_maker":
            return MLMarketMaker(**strategy_kwargs)
        if s == "ml_momentum":
            return MLMomentumStrategy(**strategy_kwargs)
        raise ValueError(f"Unknown strategy: {strategy_name}")

    # ----------------------------- Backtesting -----------------------------


    def run_backtest(self, strategy_name: str, **strategy_kwargs) -> Dict:
        """
        Run a single strategy on the precomputed event stream.
        Returns a dict of metrics and time series.
        """
        stream = self._build_event_stream()
        lob = LimitOrderBook()
        strategy = self._make_strategy(strategy_name, **strategy_kwargs)

        # Optional ML pretraining (keep as-is, but avoid multiple X/y builds)
        # We can reuse the raw DataFrame here:
        if hasattr(strategy, 'spread_predictor') or hasattr(strategy, 'momentum_predictor'):
            df = self.load_data()
            X_train, y_train = create_training_data_from_historical(df)
            if hasattr(strategy, 'spread_predictor'):
                strategy.spread_predictor.train(X_train, y_train)
            if hasattr(strategy, 'momentum_predictor'):
                strategy.momentum_predictor.train(X_train, y_train)

        # Preallocate Python lists (fast append)
        ts_arr, mid_arr, spr_arr, imb_arr, pnl_arr, pos_arr = [], [], [], [], [], []

        iterator = stream
        if self.show_progress and tqdm is not None:
            iterator = tqdm(stream, desc=f"Backtest: {strategy_name}", total=len(stream))

        for idx, (ts, sides, prices, sizes) in enumerate(iterator):
            # Apply all orders for this timestamp using batch update for maximum performance
            lob.update_batch(sides, prices, sizes)

            # Strategy step with reduced frequency for performance
            # Only update every 10th timestamp to reduce overhead
            if idx % 10 == 0:
                _ = strategy.update(lob, ts)

                # Record metrics (cheap checks)
                mp = lob.mid_price()
                if mp is not None:
                    ts_arr.append(ts)
                    mid_arr.append(mp)
                    spr_arr.append(lob.spread() or 0.0)
                    imb_arr.append(lob.order_imbalance() or 0.0)
                    pnl_arr.append(strategy.get_pnl(mp))
                    pos_arr.append(getattr(strategy, "position", 0.0))

        pnls = np.asarray(pnl_arr, dtype=np.float64)
        if pnls.size:
            rets = np.diff(pnls, prepend=pnls[0])
        else:
            rets = np.array([], dtype=np.float64)

        res = {
            "timestamps": np.asarray(ts_arr, dtype=np.int64),
            "mid_prices": np.asarray(mid_arr, dtype=np.float64),
            "spreads": np.asarray(spr_arr, dtype=np.float64),
            "imbalances": np.asarray(imb_arr, dtype=np.float64),
            "pnls": pnls,
            "positions": np.asarray(pos_arr, dtype=np.float64),
            "returns": rets,
            "total_pnl": float(pnls[-1]) if pnls.size else 0.0,
            "sharpe_ratio": self._calculate_sharpe_ratio(rets),
            "max_drawdown": self._calculate_max_drawdown(pnls),
            "win_rate": self._calculate_win_rate(rets),
            "strategy": strategy_name,
            "trades": getattr(strategy, "trades", []),
        }

        self.results[strategy_name] = res
        return res

    def run_parallel(self, jobs: List[Tuple[str, dict]], max_workers: Optional[int] = None) -> Dict[str, Dict]:
        """
        Run multiple strategies in parallel threads.
        jobs: [(strategy_name, kwargs_dict), ...]
        Returns a dict: {strategy_name: results}
        """
        # Ensure event stream is built once before threading
        _ = self._build_event_stream()

        out: Dict[str, Dict] = {}
        with ThreadPoolExecutor(max_workers=max_workers or min(4, os.cpu_count() or 2)) as ex:
            futs = {ex.submit(self.run_backtest, name, **kwargs): (name, kwargs) for name, kwargs in jobs}
            for fut in as_completed(futs):
                name, _ = futs[fut]
                out[name] = fut.result()
        return out

    # ---------------------------- Stats helpers -----------------------------

    def _calculate_sharpe_ratio(self, returns: np.ndarray, risk_free_rate: float = 0.0) -> float:
        if returns.size == 0:
            return 0.0
        excess = returns - risk_free_rate
        vol = np.std(excess)
        if vol == 0:
            return 0.0
        return float(np.mean(excess) / vol * np.sqrt(252.0))

    def _calculate_max_drawdown(self, pnls: np.ndarray) -> float:
        if pnls.size == 0:
            return 0.0
        peak = np.maximum.accumulate(pnls)
        dd = pnls - peak
        return float(np.min(dd))

    def _calculate_win_rate(self, returns: np.ndarray) -> float:
        if returns.size == 0:
            return 0.0
        return float(np.mean(returns > 0.0))

    # ------------------------------- Plotting -------------------------------

    def plot_results(self, strategy_names: Optional[List[str]] = None):
        if strategy_names is None:
            strategy_names = list(self.results.keys())
        if not strategy_names:
            print("No results to plot. Run backtest first.")
            return

        fig, axes = plt.subplots(2, 2, figsize=(15, 10))
        colors = ['C0', 'C1', 'C2', 'C3']

        for i, s in enumerate(strategy_names):
            if s not in self.results:
                continue
            r = self.results[s]
            c = colors[i % len(colors)]

            axes[0, 0].plot(r["timestamps"], r["pnls"], label=f"{s} PnL", color=c, linewidth=2)
            axes[0, 0].set_title("Portfolio Value"); axes[0, 0].set_ylabel("PnL"); axes[0, 0].grid(True, alpha=0.3); axes[0, 0].legend()

            axes[0, 1].plot(r["timestamps"], r["spreads"], label=f"{s} Spread", color=c, alpha=0.8)
            axes[0, 1].set_title("Bid-Ask Spread"); axes[0, 1].grid(True, alpha=0.3); axes[0, 1].legend()

            axes[1, 0].plot(r["timestamps"], r["imbalances"], label=f"{s} Imbalance", color=c, alpha=0.8)
            axes[1, 0].set_title("Order Imbalance"); axes[1, 0].set_xlabel("Time"); axes[1, 0].grid(True, alpha=0.3); axes[1, 0].legend()

            if r["returns"].size:
                axes[1, 1].hist(r["returns"], bins=50, alpha=0.6, color=c, label=s)
                axes[1, 1].set_title("Returns Distribution"); axes[1, 1].set_xlabel("Return"); axes[1, 1].legend()

        plt.tight_layout()

    def print_summary(self, strategy_names: Optional[List[str]] = None):
        if strategy_names is None:
            strategy_names = list(self.results.keys())

        print("\n" + "=" * 60)
        print("BACKTEST SUMMARY")
        print("=" * 60)

        for s in strategy_names:
            if s not in self.results:
                continue
            r = self.results[s]
            trades = r.get("trades", []) or []
            total_vol = sum(abs(t.get("size", 0) * t.get("price", 0)) for t in trades)

            print(f"\nStrategy: {s.upper()}")
            print("-" * 30)
            print(f"Total PnL: ${r['total_pnl']:.2f}")
            print(f"Sharpe Ratio: {r['sharpe_ratio']:.2f}")
            print(f"Max Drawdown: ${r['max_drawdown']:.2f}")
            print(f"Win Rate: {r['win_rate']:.2%}")
            print(f"Total Trades: {len(trades)}")
            print(f"Avg Trade PnL: ${(r['total_pnl'] / max(len(trades), 1)):.2f}")
            print(f"Total Volume: ${total_vol:.2f}")

# ------------------------------- Demos --------------------------------------

if __name__ == "__main__":
    print("LOB Trading System - Use the web UI: python run_ui.py")

